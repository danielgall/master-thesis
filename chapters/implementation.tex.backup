\chapter{Transformation of ACT-R to CHR}

After the comprehensive but at some point informal overview of the ACT-R theory in chapter \ref{actr_description}, this chapter presents a possible implementation of the described concepts of the ACT-R theory in CHR.

For the implementation, some special cases and details that are not exactly defined in theory have to be considered. Hence, some concepts of the theory that are implemented in this work are formalized first. The implementation in form of CHR rules sticks to those formalisms and is often very similar to them.

Additionally, the implementation is described incrementally, ie. first, a very minimal subset of ACT-R is presented that will be refined gradually with the progress of this chapter. In the end, an overview of the actual implementation as a result of this work is given.

Some of the definitions in this chapter result directly from the theory, some of them needed a further analysis of the official ACT-R 6.0 Reference Manual \cite{actr_reference} or the tutorials \cite{actr_tutorial}. 

\section{Chunk Stores}

Since chunks are the central data-structure of ACT-R, used for representation of declarative knowledge, to exchange information between modules and to state requests, this section first deals with this central part of ACT-R.

\subsection{Formal Representation of Chunks}

In the previous chapters, chunks always have been referred to in a graphical or in a verbose descriptive form. Hence, a formalism to represent chunks in a textual order is given at first. The definition is based on the definition of chunks in the ACT-R implementation.

\begin{definition}[chunk-store]
A \emph{chunk-store} $\Sigma$ is a tuple $(C,E,\mathcal{T},HasSlot,Isa)$, where $C$ is a set of chunks and $E$ a set of primitive elements, with $C \cap E = \emptyset$. $V = C \cup E$ are the \emph{values} of~$\Sigma$ and $\mathcal{T}$ a set of chunk-types. A chunk-type $(T,S) \in \mathcal{T}$ is a tuple with a type name $T$ and a set of slots $S$. The set of all slot-names is $\mathcal{S}$. 

$HasSlot \subseteq C \times \mathcal{S} \times V$ and $Isa \subseteq C \times T$ are relations and are defined as follows:

\begin{itemize}
 \item $c \enspace Isa \enspace T \Leftrightarrow$ chunk $c$ is of type $T$.
 \item $(c,s,v) \in HasSlot \Leftrightarrow v$ is the value of slot $s$ of $c$. This can also be written as $c \overset{s}{\longrightarrow} v$ and is spoken ``$c$ is connected to $v$'' or ``$v$ is in the slot $s$ of $c$''.
\end{itemize}


The function $slots: C \rightarrow \mathcal{S} \times V$ is defined as $slots(c) = \{ (s,v) | (c,s,v) \in HasSlot \}$ and $slots: \mathcal{T} \rightarrow \mathcal{S}$ as $slots((T,S)) = S$.

A chunk-store is \emph{type-consistent}, if $\forall(c,s,v) \in HasSlot: c \enspace Isa \enspace (T,S) \Rightarrow \exists s' \in S: s=s'$ and $\forall c \in C: \enspace c \enspace Isa \enspace (T,S) \Rightarrow \forall s \in S: \exists (c',s',v) \in HasSlot: c=c', s=s'$.
\end{definition}


\begin{definition}[abstract methods of a chunk store]
\label{def:abstract_methods_chunk_store}
The following methods can be defined over a chunk store $\Sigma = (C, E, \mathcal{T}, HasSlot, Isa)$:

\begin{description}
 \item[$\mathtt{chunk-type(name slot_1 slot_2 \dots slot_n)}$] adds the type $T = (\mathtt{name},\{\mathtt{slot1}, \dots, \mathtt{slotn}\})$ to the store, ie. $\mathcal{T'} = \mathcal{T} \cup \{T\}$. 
 \item[$\mathtt{add-chunk(name isa type slot_1 val_1 \dots slot_n val_n)}$] adds a new chunk to the store, ie. $C' = C \cup \{ \mathtt{name} \}$, $Isa' = Isa \cup (\mathtt{name}, (\mathtt{type}, slots(\mathtt{type}))$ and $HasSlot' = \bigcup_{i = 1}^n{\mathtt{(slot_i,val_i)}} \cup HasSlot.$ Note, that due to the expansion of $C$, the condition that $C$ and $E$ have to be disjoint may be violated. To fix this violation, the element can be removed from $E$: $E' = (E \cup C) - (E \cap C).$ 
 
 Additionally, a valid mechanism to restore type-consistency may be introduced: It might happen, that not all slots are specified in the \verb|add-chunk| method. Since it is claimed by the definition of $HasSlot$ that for all slots $s$ of a chunk $c$ there must be a $(c,s,v) \in HasSlot$, in implementations the unspecified slots are initialized as empty slots, represented by the empty value \verb|nil|.
\end{description} 
\end{definition}

\FIXME{add other methods. describe empty chunks?}

\begin{example}
 The addition-fact chunk in figure \ref{fig:chunk_addition_fact} and its chunk-type are defined as follows:\\
 \verb|chunk-type(addition-fact arg1 arg2 sum)|\\
 \verb|add-chunk(a isa addition-fact arg1 5 arg2 2 sum 7)|.
 
 This leads to the following chunk-store: 
 \begin{align*}
 (\{a\}, \{2,5,7\},\\ 
 \{(addition-fact, \{arg1, arg2, sum\})\},\\
 \{(a,arg1,5), (a,arg2,5), (a,sum,7)\},\\
 \{(a, addition-fact)\}).
 \end{align*}
 
 $slots(a) = \{(arg1,5), (arg2,2), (sum,7)\}$ and $slots((addition-fact,\{arg1, arg2, sum\}) = \{arg1, arg2, sum\}$. Hence, the store is type-consistent.
\end{example}

\begin{example}
 \FIXME{refer to empty chunks}
\end{example}


\subsection{Representation of Chunks in CHR}

Declarative knowledge is represented as a network of chunks, defined by the two relations $Isa$, specifying the belonging of a chunk to a type, and $HasSlot$, specifying the slot-value pairs of a chunk. Those relations can be translated directly into CHR by defining the following constraints representing the relations and sets:

\begin{lstlisting}
:- chr_constraint chunk_type(+).
% chunk_type(ChunkTypeName)

:- chr_constraint chunk_type_has_slot(+,+).
% chunk_type_has_slot(ChunkTypeName, SlotName).
\end{lstlisting}

The \verb|chunk_type/1| constraint represents the set $\mathcal{T}$ of chunk-types in the store, but refers only to the chunk-type names. The set of slots of a chunk-type is specified by the \verb|chunk_type_has_slot/2| constraint\footnote{For a chunk-type $T \in \mathcal{T}$, with $T = (t, S)$, there exists a \texttt{chunk\_type(t)} and for every slot $s \in S$ there is a \texttt{chunk\_type\_has\_slot(t,s)} in the constraint store.}.

For the chunks:

\begin{lstlisting}
:- chr_constraint chunk(+,+).
% chunk(ChunkName, ChunkType)

:- chr_constraint chunk_has_slot(+,+,+).
% chunk_has_slot(ChunkName, SlotName, Value)
\end{lstlisting}

The \verb|chunk/2| constraint represents both the set $C$ of chunks and the $Isa$ relation, since the presence of a constraint \verb|chunk(c,t)| signifies, that chunk \verb|c| is of a type $T = (\mathtt{t},S)$.

The $HasSlot$ relation is represented by the \verb|chunk_has_slot(c,s,v)| constraint, which really is just a direct translation of an element $(c,s,v) \in HasSlot$.

Note that all values in the just presented constraints have to be ground. This is a demand claimed by the original ACT-R implementation and makes sense, since each value in a slot of a chunk is a real, ground value and the concept of variables does not have an advantage in this context, because every element that can be stored in the brain is known by the brain.

Additionally, from the definition of a chunk store it is known, that the $HasSlot$ and the $Isa$ relations have to be left-complete. \FIXME{correct expression! correct definitions!} Therefore, for every chunk \verb|c| in the store, exactly one \verb|isa(c,t)| constraint has to be in the store. For each \verb|chunk_type_has_slot(t,s)| constraint, a \verb|chunk_has_slot(c,s,v)| constraint has to be defined. If one wants to express, that a chunk has an empty slot, he might use \verb|nil| for the value to indicate that. Note that \verb|nil| must not be a chunk name or chunk-type name.

\subsubsection{Simple Implementation of the Default Methods}

To implement the methods in definition~\ref{def:abstract_methods_chunk_store}, first a data type for chunk specifications has to be introduced. From this specification the correct constraints modeling the chunk-store are added or modified.

The straight-forward definition of a data type for chunk specifications is just to use the specification like in definition~\ref{def:abstract_methods_chunk_store}: Since \verb|(name isa type slot_1 val_1 \dots slot_n val_n)| is just a list in LISP and specifies a chunk uniquely, a similar Prolog term can be used:

\begin{lstlisting}
:- chr_type chunk_def ---> nil; chunk(any, any, slot_list).
:- chr_type list(T) ---> []; [T | list(T)].
% a list of slot-value pairs
:- chr_type slot_list == list(pair(any,any)).
:- chr_type pair(T1,T2) ---> (T1,T2).
\end{lstlisting}

This definition states that a chunk is either \verb|nil|, ie. an empty chunk, or a term \verb|chunk(Name, Type, SVP)|, where \verb|SVP| is a list of slot-value pairs. This is the direct translation of the chunk-specification used in the definition, amended by the \verb|nil| construct, that may be needed for later purposes.

The default methods can be implemented as follows:

\begin{lstlisting}[caption={rules for \texttt{add\_chunk}}]
 
\end{lstlisting}
\FIXME{add very simple solution}

\begin{lstlisting}[caption={rules for \texttt{add\_chunk\_type}}]
add_chunk_type(CT, []) <=> 
  chunk_type(CT).
add_chunk_type(CT, [S|Ss]) <=> 
  chunk_type_has_slot(CT, S), 
  add_chunk_type(CT, Ss).
\end{lstlisting}

\FIXME{add duplicate handling}




\subsubsection{Checking Type-Consistency}

\FIXME{missing}

\section{Procedural Module}

The part of the system, where the computations are performed, is the procedural module. It is the central component, that holds all the production rules, the working memory (in the buffer system) and organizes communication between modules (through buffers and requests). In the following, all of those subcomponents of the procedural module are described.

\subsection{Buffer System}

The buffer system can be regarded as a chunk-store, that is enhanced by buffers. A buffer can hold only one chunk at a time. The procedural module has a set $B$ of buffers, a chunk-store $\Sigma$ and a relation between the buffers and the chunks in $\Sigma$.

\begin{definition}[buffer system]
\label{def:buffer_system}
A \emph{buffer system} is a tuple $(B,\Sigma,Holds)$, where $B$ is a set of buffers, $\Sigma = (C, E, \mathcal{T}, HasSlot, Isa)$ a type-consistent chunk-store and $Holds \subseteq B \times (C \cup \{ \mathtt{nil} \})$ a unique and complete relation, that assigns every buffer at most one chunk that it holds. If a buffer $b$ is empty, ie. it does not hold a chunk, then $(b,\mathtt{nil}) \in Holds$.

A buffer system is \emph{consistent}, if every chunk that appears in $Holds$ is a member of $C$ and $\Sigma$ is consistent.

A buffer system is \emph{clean}, if its chunk-store only holds chunks which appear in $Holds$.
\end{definition}

For the implementation of a buffer system, the code of a chunk-store can be extended by a \verb|buffer/2| constraint, that encodes the set $B$ and the relation $Holds$ at once, since the relation is complete by definition\footnote{$\forall b \in B \enspace \exists c \in (C \cup \{ \mathtt{nil} \}): (b,c) \in Holds$}.

\subsubsection{Destructive Assignment and Consistency}
\label{destructive_assignment}

The demand of $Holds$ being unique is a form of destructive assignment as described in \cite[p. 32]{fru_chr_book_2009}, ie. if a new chunk is assigned to a buffer, the old \verb|buffer| constraint is removed and a new \verb|buffer| constraint is introduced, holding the new chunk:

\begin{lstlisting}
set_buffer(b, c) \ buffer(b, _) <=> buffer(b, c).
\end{lstlisting}

This rule ensures that only one \verb|buffer| exists for each buffer in $B$.

At the beginning of the program, a \verb|buffer| constraint has to be added for all the available buffers of the modules. This problem is discussed at a later point. \FIXME{add reference}

In addition, if a new chunk is introduced in a buffer, it also has to be present in the chunk-store, since the production system relies on the knowledge about the chunks in its buffers and chunks are essentially defined by their slots (\emph{consistency property} in definition~\ref{def:buffer_system}). Hence, every time a chunk is stored in a buffer, the \verb|add_chunk| method described in definition~\ref{def:abstract_methods_chunk_store} has to be called. This process is discussed later when talking about buffer requests in section~\ref{buffer_requests}.

\subsubsection{Buffer States}

Another formal detail of the buffer system is that buffers can have various states: \emph{busy}, \emph{free} and \emph{error}. A module is busy, if it is completing a request and free otherwise.

Since a module can only handle one request at a time and requests may need a certain time (like the retrieval request for example), the procedural module could state another request to a busy module. This is called \emph{jamming} which leads to error messages and should be avoided. One technique to avoid module jamming is to \emph{query} the buffer state in the conditional part of a production rule \cite[unit 2, p. 9]{actr_tutorial}. The possibility to query buffer states is discussed in the next section.

A buffer's state is set to \emph{error}, if a request was unsuccessful because of an invalid request specification or, in case of the declarative module for instance, a chunk that could not be found.

In CHR, a buffer state can be represented by a \verb|buffer_state(b,s)| constraint, which signifies that buffer \verb|b| has the state \verb|s|. Since every buffer has exactly one state all the time, it is required, that for every buffer there is such a constraint and it is ensured, that only one \verb|buffer_state| constraint is present for each buffer. This can be achieved by the destructive assignment method described in section~\ref{destructive_assignment}. 

At the beginning of the program, when a buffer is created (a \verb|buffer| constraint is placed into the store), a corresponding \verb|buffer_state| constraint has to be added. The initial state can be set to \verb|free|, since no request is being computed at the time of creation.

\subsection{Production Rules}

Production rules consist of a \emph{condition} part and an \emph{action} part. Syntactically, in ACT-R the condition is separated from the action by \verb|==>|. Additionally, each production rule has a name. Thus, a rule is defined by:

\begin{verbatim}
(p name condition* ==> action*)
\end{verbatim}

The condition part is also called the \emph{left hand side} of a rule (LHS) and the action part is called \emph{right hand side} (RHS).

\subsubsection{The Left Hand Side of a Rule}

Generally, a condition is either a \emph{buffer test}, ie. a specification of slot-value pairs that are checked against the chunk in the specified buffer or a \emph{buffer query}, ie. a check of the state of a buffer's module (either busy, free or error). A buffer test on the LHS of a rule is indicated by a \verb|=| followed by the buffer name of the tested buffer; a query is indicated by a \verb|?| in front of the buffer name.

The LHS of a rule may contain bound or unbound variables: \verb|=varname| is a variable with name \verb|varname|.

If the chunks in the buffers pass all buffer tests specified by the rule, the rule can fire, ie. its right hand side will be applied. The LHS is a conjunction of buffer tests, ie. there is no specific order for the tests \cite[p. 165]{actr_reference}.

\begin{example}[counting example -- left hand side]
The left hand side of the counting rule specified in the example in section~\ref{example_counting} could be defined as follows:

\begin{lstlisting}
(p count-rule
  =goal> 
    isa    count
    number =n
  =retrieval>
    isa    count-fact
    first  =n
    second =m
==>
  ... )
\end{lstlisting}

The condition part consists of two buffer tests:

\begin{enumerate}
 \item The goal buffer is tested for a chunk of type \verb|count| and a slot with name \verb|number|. The value of the slot is bound to the variable \verb|=n|.
 \item The retrieval buffer is tested for a chunk of type \verb|count-fact| that has the variable \verb|=n| in its \verb|first| slot (with the same value as the \verb|number| slot of the chunk in the goal buffer, since \verb|=n| has been bound to that value), and another value in its second slot which is bound to the variable \verb|=m|.
\end{enumerate}

\end{example}

\subsubsection{The Right Hand Side of a Rule}

For the right hand side of a rule the following actions are allowed:

\begin{description}
 \item[Buffer Modification] 
 \item[Buffer Request]
 \item[Buffer Clearing]
\end{description}


\begin{example}[counting example]
\label{ex:counting}
The counting rule specified in the example in section~\ref{example_counting} could be defined as follows:

\begin{lstlisting}
(p count-rule
  =goal> 
    isa    count
    number =n
  =retrieval>
    isa    count-fact
    first  =n
    second =m
==>
  =goal>
    number =m
  +retrieval>
    isa    count-fact
    first  =m
)
\end{lstlisting}

\FIXME{add description}

\end{example}

\subsubsection{Direct Translation of Buffer Tests}

An ACT-R production rule of the form

\begin{verbatim}
(p name
  =buffer1>
    isa    type1
    slot11 val11
    ...
    slot1n val1n
  ...
  =bufferk>
    isa    typek
    slotk1 valk1
    ...
    slotkm valkm
==>
... )
\end{verbatim}

states formally, that:

If $buffer1 Holds c \wedge c Isa type1 \wedge slot_{1,1}=val_{1,1} \wedge \dots$ \FIXME{extend} is true, then the rule matches and the RHS should be performed.

This can be directly translated into a CHR rule:

\begin{verbatim}
name @
  buffer(buffer1,C1),
  chunk(C1,type1),
  chunk_has_slot(C1,slot11,val11),
  ...
  chunk_has_slot(C1,slot1n,val1n),
  ...
  buffer(bufferk,Ck),
  chunk(Ck,typek),
  chunk_has_slot(Ck,slotk1,valk1),
  ...
  chunk_has_slot(Ck,slotkm,valkm)
==>
  ...
\end{verbatim}

This rule checks the buffer system for the existence of a buffer specified in the request holding a certain chunk and then checks the chunk store of the buffer system for that chunk with the type and slots specified in the ACT-R rule.

If the values in the slot tests are variables, they can be directly translated to Prolog variables.

The CHR rule only fires, if all the checked buffers hold chunks that meet the requirements specified in the slot tests of the ACT-R rule. Since those slot-tests are just a conjunction of relation-membership tests and the CHR rule is a translation of these tests into constraints, both are equivalent. In detail: \FIXME{geht besser}

\begin{itemize}
 \item If a checked buffer \verb|b| holds no chunk, the constraint \verb|buffer(b,nil)| will be present, but the chunk store will not hold any of the required \verb|chunk| or \verb|chunk_has_slot| constraints and the rule will not fire.
 \item If a checked buffer \verb|b| holds a chunk, but the chunk does not meet one of the requirements in its slots, the rule does not fire.
 \item The rule only fires, if for all checked buffers there are valid \verb|buffer|, \verb|chunk| and \verb|chunk_has_slot| constraints present that meet all the requirements specified by the ACT-R rule.
 \item Variables on the LHS of a rule are bound to the values of the actual constraints that are tried for the matching. This corresponds to the semantics of a ACT-R production rule with variables on the LHS.
\end{itemize}

\FIXME{ist die begr端ndung schl端ssig? evtl section 端ber variablen hier einf端gen}
\FIXME{add some words about double chunk checks}

\begin{example}[counting example in CHR -- simple]
The production rule in example~\ref{ex:counting} can be translated to:

\begin{lstlisting}
count-rule @
  buffer(goal,C1), 
    chunk(C1,count),
    chunk_has_slot(number,N),
  buffer(retrieval,C2),
    chunk(C2,count-fact),
    chunk_has_slot(first,N),
    chunk_has_slot(second,M)
==>
  buffer_change(goal    number =m
  +retrieval>
    isa    count-fact
    first  =m
)
\end{lstlisting}

\end{example}


\subsection{Translation of Buffer Queries}

A buffer query

\begin{lstlisting}
...
?buffer>
  state  bstate 
...
==> ...
\end{lstlisting}

on the LHS of a production rule can be translated to the following CHR rule head:

\begin{lstlisting}
...
buffer_state(buffer,bstate) 
...
==> ...
\end{lstlisting}






\subsubsection{The Production Rule Grammar}

The discussed concepts lead to the following grammar for production rules, which is a simplified version of the actual grammar used in the original ACT-R implementation \cite[p. 162]{actr_reference}. 


\begin{lstlisting}
production-definition ::= (p name condition* ==> action*)
name ::= a symbol that serves as the name of the production for reference
condition ::= [ buffer-test | query ]
action ::= [buffer-modification | request | buffer-clearing | output | ]
buffer-test ::= =buffer-name> isa chunk-type slot-test*
buffer-name ::= a symbol which is the name of a buffer
chunk-type ::= a symbol which is the name of a chunk-type in the model
slot-test ::= {slot-modifier} slot-name slot-value
slot-modifier ::= [= | - | < | > | <= | >=]
slot-name ::= a symbol which names a possible slot in the specified chunk-type
slot-value ::= a variable or any Lisp value
query ::= ?buffer-name> query-test*
query-test ::= {-} queried-item query-value
queried-item ::= a symbol which names a valid query for the specified buffer
query-value ::= a bound-variable or any Lisp value
buffer-modification ::= =buffer-name> slot-value-pair*
slot-value-pair ::= slot-name bound-slot-value
bound-slot-value ::= a bound variable or any Lisp value
request ::= +buffer-name> isa chunk-type request-spec*
request-spec ::= {slot-modifier} slot-name slot-value
request-parameter ::= a Lisp keyword naming a request parameter provided by the buffer specified
buffer-clearing ::= -buffer-name>
variable ::= a symbol which starts with the character =
output ::= !output! [ output-value ]
output-value ::= any Lisp value or a bound-variable
bound-variable ::= a variable which is used in the buffer-test conditions of the production (including a
variable which names the buffer that is tested in a buffer-test or dynamic-buffer-test) or is bound with
an explicit binding in the production
\end{lstlisting}

Some of the details in this grammar that have not been discussed yet are presented in the following.

\subsubsection{Bound and Unbound Variables}

\subsubsection{Slot Modifiers}

In ACT-R, slot-tests can be preceded by \emph{slot modifiers}. Those modifiers allow to specify tests like inequality (\verb|-|) or arithmetic comparisons (\verb|<, >, <=, >=|) of the slot value of a chunk with the specified variable or value. Since the slots in a chunk store are always fully defined with ground values, those tests are decidable.

If no slot modifier is specified in a slot test, the default modifier \verb|=| is used, that states that the chunk in the specified buffer must have the specified value in the specified slot. This default semantics has been used in the previous sections when translating simple ACT-R rules to CHR and is performed automatically by the matching of CHR.

To translate the other slot modifiers to CHR, another CHR mechanism can be used: Guards. Since the allowed modifiers are all default built-in constraints\footnote{ie. Prolog predicates}, a slot test with a modifier

\begin{lstlisting}
...
=buffer>
  ...
  ~slot  val
...
==>
\end{lstlisting}

where \verb|~| stands for a modifier in \{ \verb|=,-,<,>,<=,>=| \}can be translated as follows:

\begin{lstlisting}
buffer(buffer,C),
  ...
  chunk_has_slot(C,slot,V),
  ...
==>
  V # val |
  ...
\end{lstlisting}

where \verb|#| is the placeholder for the built-in constraint that computes the test specified by \verb|~| and \verb|V| is a fresh variable that has not been used in the rule, yet.

For arithmetic slot modifiers the values being compared have to be numbers. If a value is not a number, the arithmetic test will fail and the rule cannot be applied \cite{actr_reference}.

Note, that slot tests with modifiers other than \verb|=| do not bind variables, but only perform simple checks, like it is with guards in CHR. If \verb|val| is an unbound variable and is never bound to a value on LHS, the default implementation throws a warning, and the rule will not match. Therefore, to handle this case, the rule translation scheme has to be amended with an additional guard check \verb|ground(Val)|, where \verb|Val| is the Prolog variable that replaces each occurrence of the variable \verb|val|.

As with normal slot tests, it is important to mention that if there are several tests on the same slot, the \verb|chunk_has_slot| constraint must appear only once on the LHS of the CHR rule, since every slot-value pair is unique in the constraint store. Ie., if the first slot test of a particular slot appears on the LHS of the ACT-R rule, a \verb|chunk_has_slot| constraint has to be added to the LHS of the CHR rule. For every other occurrence of this slot in a slot test, only guard checks are added.

\begin{example}
To clarify the details of the matching concept in ACT-R, here are some examples and their behaviour:

\begin{lstlisting}
=buffer>
  isa    foo
  -spam  =bar
\end{lstlisting}

will throw a warning when loading the model. When running it, the rule will never fire, since no chunk value will match the inequality to the unbound variable \verb|bar|.

\begin{lstlisting}
=buffer>
  isa    foo
  -spam  =bar
  eggs   =bar
\end{lstlisting}

will fire, if there is a chunk whose value in \verb|eggs| is different from the value in \verb|spam|.

\begin{lstlisting}
=buffer>
  isa    foo
  spam  =bar
  spam  =eggs
\end{lstlisting}

matches for every value of the spam slot. The translation to CHR is:

\begin{lstlisting}
buffer(buffer,C),
  chunk(C,foo),
  chunk_has_slot(C,spam,Bar),
==>
  Bar=Eggs |
  ...
\end{lstlisting}

\begin{lstlisting}
=buffer>
  isa    foo
  spam  =bar
  spam  =eggs
  ham   =eggs
\end{lstlisting}

will match all chunks which have the same value in \verb|spam| and \verb|ham|. \FIXME{CHR translation???}

\end{example}


\subsubsection{Empty Slots}

An important special case in the semantics of ACT-R production rules is, that if there is a slot test specified, then a potential chunk only matches, if it really has a value in this slot. Chunks that have \verb|nil| in a slot specified in a buffer test, will not match the test. Hence, variables can not be used to test if two slots have the same value and the value is \verb|nil|, since every positive slot test involving \verb|nil| fails automatically \cite[p. 164, section ``Variables'', last sentence]{actr_reference}.

In CHR this special case can be handled, by adding a guard for each variable occurring in a positive slot-test checking that this variable does not equal \verb|nil|.

For negated slot tests, this is not the case: 

\begin{lstlisting}
=buffer>
  isa    foo
  -spam  4
\end{lstlisting}

matches also a chunk with an empty \verb|spam| slot (\verb|nil| in its \verb|spam| slot).



\subsubsection{Outputs}






\section{Modular Organization}

The term \emph{module} is highly overloaded, since in ACT-R it describes independent parts of human cognition, whereas in programming terms the term is used in a slightly different manner. In the following, implementational modules will always be named explicitly as \emph{Prolog modules}.

Nevertheless, the modular organization of ACT-R with its independent modules, can be implemented by defining a Prolog module for each ACT-R module\footnote{and adding some modules around them}. In the following, the concept of Prolog modules is explained.

\subsection{Prolog Modules}

Defining a new module creates a new namespace for all CHR constraints and Prolog predicates, which is illustrated in the following example:

\begin{example}[Prolog Modules and CHR]

\begin{lstlisting}[caption={Definition of Module 1},label=lst:mod1]
:- module(mod1,[]).
:- use_module(library(chr)).

:- use_module(mod2).

:- chr_constraint a/0, b/0.

a <=> c.
\end{lstlisting}

\begin{lstlisting}[caption={Definition of Module 2},label=lst:mod2]
:- module(mod2,[c/0]).
:- use_module(library(chr)).

:- use_module(mod1).

:- chr_constraint a/0, b/0, c/0. 

a <=> b.
b <=> mod1:a.
\end{lstlisting}


In this definition, two new modules \verb|mod1| and \verb|mod2| are created and only the \verb|c| constraint of \verb|mod2| is exported, indicated by the lists in the module definitions.

The CHR constraint \verb|a| in listing~\ref{lst:mod1} is internally represented as \verb|mod1:a|, so it lives in its own namespace and does not pollute other namespaces. The constraint can appear on the right hand side of rules of other modules, but has to be called explicitly with its full namespace. In line~8 of listing~\ref{lst:mod2}, the presence of the local \verb|a| constraint leads the rule to fire and \verb|mod2:a| is replaced by \verb|mod2:b|, which leads the rule in line~9 to fire and replaces the local \verb|mod2:b| constraint by an external \verb|mod1:a| constraint. So, external constraints can be called by their complete identifiers.

However, on the left hand side of a rule, only the constraints local to the current module can appear. 

Exported constraints can only appear once in a program, since they can be called without their namespace definition, which is demonstrated in line~8 of listing~\ref{lst:mod1}, where \verb|mod2:c| is called in \verb|mod1| without referring to \verb|mod2| explicitly.
\end{example}

\subsection{Interface for Module Requests}

The architecture of ACT-R provides an infrastructure for the procedural module to state requests to all the other modules. To implement this concept as general as possible, an interface has to be defined, which allows the adding of new modules to the system by just implementing this interface.


interface for requests

\section{Declarative Module}

uses chunks as defined in section ??: dm is a chunk store that implements the module interface. 

\subsection{Retrieval Requests}

interface module request

\subsection{Chunk Merging}


\section{Timing in ACT-R}

scheduling, define recognize-act-cycle in detail

\subsection{Priority Queue}


\section{Subsymbolic Layer}

\subsection{Activation of Chunks}

\subsection{Production Utility}

